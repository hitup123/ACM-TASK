# ACM-TASK
ACM Research domain Task Submission
<p><h2>Schnorr Zero Knowledge Proofs</h2><br> • What is Schnorr Zero Knowledge
Proofs? <br>The Schnorr Zero Knowledge proof or Schnorr protocol is a
digital signature scheme based on discrete logarithms. Discrete
logarithms are basically Bx=A .<br>The goal of Schnorr Zero-Knowledge Proofs
(ZKPs) is to enable one party (the prover) to prove to another party
(the verifier) that a statement is true without revealing any additional
information about the transaction.<br> <br>• <strong>Schnorr Zero-Knowledge Proofs</strong>
(ZKPs) are used in:</p>
<ol type="1">
<li>Digital Signatures: Ensures message integrity without revealing the
signing key.</li>
<li>Authentication: Proves knowledge of a secret without disclosing
it.</li>
<li>Privacy-Preserving Protocols: Validates statements without revealing
sensitive information.</li>
<li>Key Exchange: Facilitates secure sharing of secret keys.</li>
<li>Blockchain and Cryptocurrencies: Enhances transaction privacy and
efficiency.</li>
<li>Secure Multi-party Computation (MPC): Allows joint computation
without revealing inputs. Overall, Schnorr Zero-Knowledge Proofs offer
robust solutions for building secure and privacy-preserving
cryptographic protocols across various domains, including information
security, privacy, and distributed systems.</li>
</ol>
<p>• <strong> Parts of Schnorr ZKP</strong>: <br>Commitment: The prover generates/calculates
the commitment. Essentially, it’s a way for a prover to lock in a value
in such a way that they cannot change it later, while still keeping the
value hidden from others. The commitment is calculated as
g<random value> %p Challenge: The challenge is sent by the verifier. In
the code Its calculated by concatenating the commitment, the public key
and generator value and hashing it using the SHA256 hashing. Response:
The prover calculates the response based on the given challenge. The
response is calculated as (<random value> + private key * challenge) % q
Verification: The verifier now check if gs = (commitment* ((public
key)challenge %p))%p
  <p>• <strong>Variable Description</strong> <ol>
    <li><strong>p:</strong> p is any large prime number.</li>
    <li><strong>q:</strong> q is also a prime number such that q divides (p-1).</li>
    <li><strong>g:</strong> It is a number less than p such that g^((p-1)/q) % p != 1. Also called the generator.</li>
    <li><strong>Random value:</strong> A random number.</li>
    <li><strong>Private Key:</strong> It is the private key or the secret that the prover is trying to show they know to the verifier.</li>
    <li><strong>Public Key:</strong> Public key related to the private key.</li>
</ol>
</p>
<p>• Explanation of the code:<br> We start by choosing the q value is
generated by using the randint() function which chooses any n bit
number(here 15 bit number is chosen to reduce computational load). From
this we calculate the p-1 as a multiple of q such that p(p-1+1) is a
prime. Its easier here to generate p from q as it prevents the prime
factorization of a large prime number. Then we calculate the generator
values g such that g(p-1/q) %p! =1. These values are fed to an object of
the class SchnorrZKProof which has functions to generate the hash,
compute the commitment, response, public and private keys and
verification. The private is just random number less than q. The private
key is hence found from this as gprivate key% p. The hash function uses
SHA256 to compute the challenge which is just the concatenation of the
commitment, the public key and generator value. The response is computed
as (<random value> + private key * challenge) % q The verification of
the response is done using gs = (commitment* ((public key)challenge
%p))%p The LHS and RHS of the equation are separately calculated and
checked if equal. In practical scenarios the output of the verify()
function returning as false would conclude that the prover does not the
secret that its being asked by the verifier. A true result would show
that the prover indeed does know the secret.</p>
